package com.sgametrio.wsd;

import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Scanner;
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.concurrent.TimeUnit;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;

import org.w3c.dom.Document;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;

import evaluation.InputExtractor;
import evaluation.InputInstance;
import evaluation.Scorer;

public class WsdLauncher {
	
	//settings, used to make code clearer, use params in WsdExecutor for development
	public static void main(String a[]){
		//sentence to be disambiguated
		String[] sentences = {
//				"Eat what you can, and, I'll have the rest.",
//				"Dan speaks three languages, is good a DIY, and he can cook.",
//				"He made such a terrible face that the children ran away.",
////				ambiguous sentences
				"I saw him sawing wood with a saw", //saw
//				"I took out my contact lenses and put on my glasses.", //glass
//				"The water, spilled over the tops of these, \"river\" banks during the last flood." //river
		};
		boolean centrality = !Globals.runSolver;
		//launchDisambiguation(saveExamples, saveGml, verbose, runSolver, sentences, centrality);
		launchDisambiguationEvaluation(centrality);
		//launchEvaluator(Globals.currentGoldFile, "RESULTS/centrality_wsdResults.KEY");
		//launchEvaluator(Globals.pathToSenseval3 + Globals.goldFileSuffix, "RESULTS/senseval3_centrality.KEY");
		//launchEvaluator(Globals.currentGoldFile, "RESULTS/ALL_subTrees_wsdResults.KEY");
	}

	
	/**
	 * launches disambiguation to calculate performances
	 * @param saveExamples
	 * @param saveGml
	 * @param verbose
	 * @param treeKernelType
	 */
	private static void launchDisambiguationEvaluation(boolean centrality){
		MyExecutor myExecutor = new MyExecutor();
		//deletes all files generated by previous executions
		clearOldFiles();
		if (Globals.saveGml) {
			myExecutor.createDir(Globals.gmlPath);
		}
		myExecutor.createDir(Globals.resultsPath);
		long startTime = System.nanoTime();
		// TODO: move this code to InputExtractor
		try {
			DocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance();
			DocumentBuilder dBuilder = dbFactory.newDocumentBuilder();
			Document doc = dBuilder.parse(new File(Globals.currentDataFile));
			//optional, but recommended
			doc.getDocumentElement().normalize();
			//get all sentences in xml file
			NodeList allSentences = doc.getElementsByTagName("sentence");
			// Delete old result file
			if (centrality) {
				FileWriter deleteOldResultsFile = new FileWriter(Globals.resultsPath + Globals.fileNameCentrality + Globals.resultsFileName);
				deleteOldResultsFile.close();
			} else {
				FileWriter deleteOldResultsFile = new FileWriter(Globals.resultsPath + Globals.fileName + Globals.resultsFileName);
				deleteOldResultsFile.close();
			}
			
			// Create thread pool
			ExecutorService executor = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors());			
			//iterate over all sentences and send them to inputExtractor to be processed
			for (int sentIndex = 0; sentIndex < allSentences.getLength(); sentIndex++) {
				Node sentence = allSentences.item(sentIndex);
				ArrayList<InputInstance> instances = InputExtractor.myExtractInput(sentence);
				SentenceRunner runner = new SentenceRunner(myExecutor, instances, centrality);
			    executor.execute(runner);
			}
			
			// Start evaluation only when all thread are finished
			executor.shutdown();
			// wait until all are finished
			while (!executor.isTerminated());
			System.out.println("Finished results");

			//launch Navigli's evaluation framework script
			if (centrality) {
				launchEvaluator(Globals.currentGoldFile, Globals.resultsPath+Globals.fileNameCentrality+Globals.resultsFileName);
			} else {
				launchEvaluator(Globals.currentGoldFile, Globals.resultsPath+Globals.fileName+Globals.resultsFileName);
			}	
		} catch (Exception e) {
			System.err.print(Thread.currentThread().getStackTrace()[1].getMethodName()+" threw: ");
			System.err.println(e);
		}

		long endTime = System.nanoTime();

		long duration = (endTime - startTime)/1000000000; // in seconds
		System.out.println("Time executed (in seconds): " + duration);
		// Remember to close dictionary
		myExecutor.closeDictionary();
	}
	
	/**
	 * Execute Navigli's evaluation script
	 * @param goldStandardPathToFile
	 * @param resultsPathToFile
	 */
	public static void launchEvaluator(String goldStandardPathToFile, String resultsPathToFile){
		String[] goldAndRes = {goldStandardPathToFile, resultsPathToFile};
		try {
			Scorer.main(goldAndRes);
		} catch (IOException e) {
			System.err.print(Thread.currentThread().getStackTrace()[1].getMethodName()+" threw: ");
			System.err.println(e);
		}
	}
	
	/**
	 * clear all old files generated by tsp solver and wsd algorithm (.tour, .gtsp, log, .gml).
	 */
	private static void clearOldFiles(){
		File gml = new File(Globals.gmlPath);
		File gtsp = new File(Globals.gtspPath);
		File tour = new File(Globals.tourPath);
		File log = new File("log.txt");
		if (gml.isDirectory()) {
			for(File gmlFile: gml.listFiles()){
				gmlFile.delete();
			}
		}
		if (gtsp.isDirectory()) {
			for(File gtspFile: gtsp.listFiles()){
				gtspFile.delete();
			}
		}
		if (tour.isDirectory()) {
			for(File tourFile: tour.listFiles()){
				tourFile.delete();
			}
		}
		log.delete();
	}
}
